#!/usr/bin/env bash
#
#   Caddy Installer and Upgrade Script
#
#   Homepage: https://caddyserver.com
#   Issues:   https://github.com/caddyserver/getcaddy.com/issues
#   Requires: bash, coreutils, sed, grep, curl or wget, tar or unzip
#
# Bash script to install the single-binary Caddy web server. Use it like this:
#
#   $ curl https://getcaddy.com |bash
#	or
#	  $ wget -qO- https://getcaddy.com |bash
#
# In automated environments, you may want to run as root.
# If using curl, we recommend using the -fsSL flags.
#
# If you want to get Caddy with extra features, use -s with a
# comma-separated list of directives, like this:
#
#	  $ curl https://getcaddy.com |bash -s git,mailout
#
# Or it can be first downloaded and then run:
#
#   $ wget getcaddy.com -O getcaddy.sh
#   $ bash getcaddy.sh git,mailout
#
# See https://caddyserver.com/download for the full list of available features.
#
# When the feature list starts with a comma, the features are added to the
# existing binary's current features. A sole comma means: keep the same features.
#
# If no features wanted, specify 'none' as the feature list.
# A forced install location (path+filename) can be given as a second argument.
#
#   $ bash getcaddy.sh none /root/caddyserver
#
# This should work on Mac, Linux, and BSD systems, and
# hopefully Windows with Cygwin. Please open an issue if you notice any bugs.
#

install_caddy()
{
	trap 'echo -e "Aborted, error $? in command: $BASH_COMMAND"; trap ERR; return 1' ERR

	#########################
	# Which OS and version? #
	#########################

	# Determine arch (and arm)
	# NOTE: `uname -m` is more accurate and universal than `arch`
	# See https://en.wikipedia.org/wiki/Uname
	caddy_arm=""
	unamem="$(uname -m)"
	if [[ $unamem == *aarch64* ]]; then
		caddy_arch="arm64"
	elif [[ $unamem == *64* ]]; then
		caddy_arch="amd64"
	elif [[ $unamem == *86* ]]; then
		caddy_arch="386"
	elif [[ $unamem == *armv5* ]]; then
		caddy_arch="arm"
		caddy_arm="5"
	elif [[ $unamem == *armv6l* ]]; then
		caddy_arch="arm"
		caddy_arm="6"
	elif [[ $unamem == *armv7l* ]]; then
		caddy_arch="arm"
		caddy_arm="7"
	else
		echo "Aborted, unsupported or unknown architecture: $unamem"
		return 2
	fi

	# Determine os, binary name and package type
	caddy_bin="caddy"
	caddy_dl_ext=".tar.gz"
	uname="$(uname)"
	declare -u unameu=$uname
	if [[ ${unameu} == *DARWIN* ]]; then
		caddy_os="darwin"
		caddy_dl_ext=".zip"
		vers=$(sw_vers)
		version=${vers##*ProductVersion: }
		IFS='.' read OSX_MAJOR OSX_MINOR _ <<<"$version"

		# Major
		if ((OSX_MAJOR < 10)); then
			echo "Aborted, unsupported OS X version (9-)"
			return 3
		fi
		if ((OSX_MAJOR > 10)); then
			echo "Aborted, unsupported OS X version (11+)"
			return 4
		fi

		# Minor
		if ((OSX_MINOR < 5)); then
			echo "Aborted, unsupported OS X version (10.5-)"
			return 5
		fi
	elif [[ ${unameu} == *LINUX* ]]; then
		caddy_os="linux"
	elif [[ ${unameu} == *FREEBSD* ]]; then
		caddy_os="freebsd"
	elif [[ ${unameu} == *OPENBSD* ]]; then
		caddy_os="openbsd"
	elif [[ ${unameu} == *WIN* ]]; then
		# Should catch cygwin
		caddy_os="windows"
		caddy_dl_ext=".zip"
		caddy_bin=$caddy_bin.exe
	else
		echo "Aborted, unsupported or unknown os: $uname"
		return 6
	fi

	# determine install location, caddy_path is the full path
	pid=$(pgrep -nx "$caddy_bin" || true)  # most recent match if running
	if [[ $2 ]]; then  # if specified: force that install location
		caddy_path="$2"
		[[ ${caddy_path:0:1} = / ]] || caddy_path="./$caddy_path"
	elif [[ $pid ]]; then  # if running: use location of the binary
		bin=$(ls -l /proc/$pid/exe)
		caddy_path=$(sed "s@^.* /proc/$pid/exe -> @@" <<<"$bin")
	else
		caddy_path=$(type -p "$caddy_bin" || true)  # use the first caddy binary in PATH
	fi

	# find the curl or wget binaries
	if dl_cmd="$(type -p curl || true) -fsSL"; then  # no curl
		if dl_cmd="$( type -p wget || true) -qO-"; then  # no wget
			echo "Aborted, could not find curl or wget"
			return 8
		fi
	fi

	###################
	# Which features? #
	###################

	# determine valid features
	valid_features=$($dl_cmd caddyserver.com/features.json \
			|sed 's/},/\0\n/g' |grep -o '^.*","name":"[^"]*' |grep -o '[^"]*$')
	valid_features=",$(sed 's/ /,/g' <<<$valid_features),"

	features=$1
	[[ $features = none ]] && features=""

	# if features starts with comma: get the current plugins
	if [[ ${features:0:1} = ',' ]]; then
		# if no binary found, just install a new one with the listed features
		if [[ -x $caddy_path ]]; then  # read plugins from binary if present
			plugins=$("$caddy_path" -plugins |grep ' http\.' |sed 's/^.*http\.//')
			# only add valid features in the plugins list
			for plugin in ${plugins[@]}; do
				[[ $valid_features = *,$plugin,* ]] && features+=",$plugin"
			done
		fi
	fi

	# validate the specified features
	featurelist=($(sed 's/,/ /g' <<<"$features"))
	for feature in "${featurelist[@]}"; do
		if [[ $valid_features != *,$feature,* ]]; then
			echo "Aborted, feature '$feature' not valid"
			return 7
		fi
	done
	# remove extraneous commas
	caddy_features=$(sed 's/ /,/g' <<<${featurelist[@]})

	# determine fresh install location
	if [[ -z $caddy_path ]]; then
		install_path="/usr/local/bin"

		# Termux on Android has $PREFIX set which already ends with /usr
		if [[ -n "$ANDROID_ROOT" && -n "$PREFIX" ]]; then
			install_path="$PREFIX/bin"
		fi

		# Fall back to /usr/bin if necessary
		if [[ ! -d $install_path ]]; then
			install_path="/usr/bin"
		fi
		caddy_path="$install_path/$caddy_bin"
	fi

	########################
	# Download and extract #
	########################

	echo "Downloading Caddy for $caddy_os/$caddy_arch..."
	[[ -n "$ANDROID_ROOT" && -n "$PREFIX" ]] && tmp=$PREFIX/tmp || tmp=/tmp
	caddy_dl="$tmp/caddy_${caddy_os}_$caddy_arch${caddy_arm}_custom$caddy_dl_ext"
	caddy_url="https://caddyserver.com/download/build?os=$caddy_os&arch=$caddy_arch&arm=$caddy_arm&features=$caddy_features"
	echo "$caddy_url"
	$dl_cmd "$caddy_url" >"$caddy_dl"

	echo "Extracting..."
	case "$caddy_dl" in
		*.zip)    unzip -o "$caddy_dl" "$caddy_bin" -d "$tmp/" ;;
		*.tar.gz) tar -xzf "$caddy_dl" -C "$tmp/" "$caddy_bin" ;;
	esac
	chmod +x "$tmp/$caddy_bin"

	# Not every platform has or needs sudo (see issue #40)
	((EUID)) && [[ -z "$ANDROID_ROOT" ]] && sudo_cmd="sudo"

	# Back up existing caddy, if any
	caddy_cur_ver="$("$caddy_path" -version 2>/dev/null | cut -d ' ' -f2)"
	if [[ $caddy_cur_ver ]]; then
		# caddy of some version is already installed
		caddy_backup="${caddy_path}_$caddy_cur_ver"
		echo "Backing up $caddy_path to $caddy_backup"
		echo "(Password may be required.)"
		$sudo_cmd cp -v --backup=numbered "$caddy_path" "$caddy_backup"
	fi

	[[ $pid ]] && echo "Stopping caddy" && kill -SIGINT $pid
	echo "Putting caddy in $caddy_path (may require password)"
	$sudo_cmd mv "$tmp/$caddy_bin" "$caddy_path"
	if setcap_cmd=$(type -p setcap); then
		$sudo_cmd "$setcap_cmd" cap_net_bind_service=+ep "$caddy_path"
	fi
	[[ $pid ]] && echo "Restarting caddy" && "$caddy_path"
	$sudo_cmd rm -- "$caddy_dl"

	# check installation
	echo "Version: $("$caddy_path" --version)"

	echo "Successfully installed"
	trap ERR
	return 0
}

install_caddy "$@"
return=$?
((return)) && echo "Not completed, aborted at $return"
